# Още работа със списъци

## List Comprehension
```haskell
[<expr> | <gen1>, ..., <genK>, <cond1>, ..., <condS>]
```

## Конструкция case
```haskell
case e of
    p1 -> e1
    p2 -> e2
    ...
    pk -> ek 
```

## Безкрайни списъци
```haskell
ones = 1 : ones {- ?!? -}
```

Нещо интересно:
```haskell
fibs = 0 : 1 : [a + b | (a, b) <- zip fibs (tail fibs)]
```


# Задачи за упражнение
1) Да се напише функция, която по подаден списък от числа и число n връща наредена двойка, в която първият елемент е списък от първите n числа в списъка, а вторият - списък от останалите елементи.
```haskell
takeFirstN :: [Int] -> Int -> ???
```

2) Да се напише функция, която по списък от наредени двойки от символ и число връща низ, получен по следния начин:
```haskell
[(ch1, n1), ..., (chM, nM)] = n1 пъти символа ch1, n2 пъти символа ch2, ..., nM пъти символа chM
```
```
simpleDecode :: [(Char, Int)] -> String
```

3) Да се напише функция, която слива два сортирани списъка.
```haskell
merge :: [Int] -> [Int] -> [Int]
```

4) Да се реализира алгоритъма за бързо сортиране.
```haskell
quickSort :: [Int] -> [Int]
```

5) Да се напише функция, която разделя подаден списък на списък от списъци всеки с дължина n. В случай че дължината на изходния списък не се дели точно на n, да се игнорират последните елементи.
```haskell
split :: [a] -> Int -> ???
```

6) ("Домашно") Да се напише функция, която премахва излишните интервали от подаден низ, т.е. низът да не започва или завършва с интервал/и и между всеки две последователни думи да има по точно един интервал. Ако няма думи в низа, резултатът да бъде празен списък.

7) Да се напише функция, която по подадено число n връща списък от първите n прости числа.
```haskell
firstNPrimes :: Int -> [Int]
```