# Домашна работа по **Функционално програмиране**
## *спец. Информационни системи, група 4*

### Част 1.
*(10т.) Задача 1.* Да се напише функция, която по подаден списък от числов тип и нареден тип *lst* и естествено число *k* изчислява минималното произведение на *k* последователни елемента на списъка. Приемете, че *0 < k < length lst*.
```haskell
minWindowProduct :: -- подходящ тип

minWindowProduct [1, 2, 3, 4, 5, 0] 3 -- Очакван изход: 0
minWindowProduct [1, -2, 3, -4, 5, 0] 2 -- Очакван изход: -20
```

*(10т.) Задача 2.* Да се дефинира функция, която получава списък *lst* от тип, за който е дефиниран оператор за равенство, и връща списък от списъци, всеки от елементите на който съдържа различни елементи от подадения *lst*(всеки елемент от *lst* се съдържа в точно един от елементите на резултатния списък). Резултатният списък трябва да е с възможно най-малко елементи, като подредбата на елементите е произволна.
```haskell
minimalSplit :: --подходящ тип

minimalSplit [1,2,3,4,2,3,2,1] -- Примерен изход: [[1,2,3,4],[2,3],[2,1]]
```

*(10т.) Задача 3.* Да се състави безкраен списък, елементите на който представляват съответните редове на известния триъгълник на Паскал.  
```haskell
pascalTriangle :: [[Integer]]
pascalTriangle = -- подходяща дефиниция

take 5 pascalTriangle -- Примерен изход: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```
*Упътване:* Помислете как се образува всеки ред от предишния.

*(20т.) Задача 4.* Тази задача разглежда опростен калкулатор на логически изрази. Нека е даден низ, описващ логически израз, който съдържа единствено части от вида:
- символи 'T' и 'F', които описват съответно истина и лъжа;
- символите '&', '|', '!', които съответстват на логическо и, логическо или и отрицание;
- естествени числа(последователности от цифри без интервали между тях);
- идентификатори на променливи - малка латинска буква;
- интервали.  

Между всяка част в израза има поне един интервал. Да се напише функция, която получава низ от гореописания вид и списък от наредени двойки, първият елемент на всяка от които е идентификатор от израза, а вторият - логическа стойност, с която да се замести. Единствено числото 0 се оценява с лъжа, а всяко друго естествено число - с истина. Функцията връща стойността на израза. Не е необходимо да валидирате входните данни.
```haskell
calcBoolExpr :: String -> [(Char, Bool)] -> Bool

calcBoolExpr "T & F" [] -- Очакван резултат: False
calcBoolExpr "T & F" [('x', False)] -- Очакван резултат: False
calcBoolExpr "! T & T | x" [('x', True)] -- Очакван резултат: True
calcBoolExpr "! x & 0 | y & ! 3 | F" [('x', True), ('y', False)] -- Очакван резултат: False
calcBoolExpr "T | ! 0 & x | y" [('x', False), ('y', False)] -- Очакван резултат: True
calcBoolExpr "! x & ! 1 | z & y | ! 0" [('x', False), ('y', True), ('z', False)] -- Очакван резултат: True
```
*Припомняне:* Отрицанието се отнася за непосредствено следващата го променлива или константа, а приоритетът на логическото И е по-висок от този на логиеското ИЛИ.

### Част 2.
*Задача 1.* Списък от лаптопи се представя така:
```haskell
laptops = [Laptop { brand = "Dell", year = 2020, ramGB = 16, price = 1500.0 },
           Laptop { brand = "Apple", year = 2021, ramGB = 8, price = 2000.0 },
           Laptop { brand = "Lenovo", year = 2020, ramGB = 32, price = 1800.0 },
           Laptop { brand = "Asus", year = 2019, ramGB = 16, price = 1200.0 },
           Laptop { brand = "Dell", year = 2021, ramGB = 8, price = 1000.0 }]
```
- *(5т.)* Да се напише подходящ тип с конструктор Laptop.
- *(5т.)* Да се напише функция, която приема списък от лаптопи и връща функция на един параметър - наредена двойка от низ *brand* и число *year*, която при извикване връща средната цена на лаптопите, произведени от тази марка след посочената година.
```haskell
createAvgPriceFunc :: [Laptop] -> (String, Int) -> Double

func = createAvgPriceFunc laptops
func ("Dell", 2019) -- Очакван резултат: 1250.0
``` 
- *(5т.)* Да се напише функция, която приема списък от лаптопи, списък от естествени числа(брой лаптопи от съответен вид, които ще се закупят) и списък от наредени двойки - (марка,надценка), който представя допълнителните разходи(в процент от цената) при закупуване на лаптоп от конкретен производител.
```haskell
getTotalPrice :: [Laptop] -> [Int] -> [(String, Double)] -> Double

getTotalPrice laptops [1,2,3,4,5] [("Apple", 0.5), ("Asus", 0.1), ("Dell", 0.2), ("Lenovo", 0)] -- Очакван резултат: 22480.0
```

- *(5т.)* Да се напише функция, която по подаден списък от лаптопи намира годината, през която "се е произвело" най-много RAM памет.
```haskell
findYear :: [Laptop] -> Int

findYear laptops -- Очакван резултат: 2020
```

*Задача 2.* Нека е дадена следната дефиниция на тип двоично дърво с целочислени числа във възлите:
```haskell
data BinTree = Nil | Node Int BinTree BinTree

tree :: BinTree
tree = Node 5 (Node 4 Nil Nil)
              (Node 3 (Node 1 Nil NIl)
                      (Node 2 Nil Nil))

tree2 :: BinTree
tree2 = Node 5 (Node 4 (Node 8 Nil Nil) Nil)
               (Node 3 (Node 1 Nil NIl)
                       (Node 2 Nil Nil))
```

- *(5т.)* Да се напише предикат, който по подадени две двоични дървета връща истина точно когато те съвпадат, т.е. имат точно един и същ вид(еднаква дълбочина, еднаква разклоненост, еднакви елементи във възлите и т.н.).
```haskell
areEqual :: BinTree -> BinTree -> Bool

areEqual tree tree -- Очакван резултат: True
areEqual tree tree2 -- Очакван резултат: False
```

- *(5т.)* Да се напише функция, която по подадено дърво връща неговия огледален вариант(размяна на лявото и дясното дете).
```haskell
mirrorTree :: BinTree -> BinTree

expectedResult :: BinTree
expectedResult = Node 5 (Node 3 (Node 2 Nil NIl)
                                (Node 1 Nil Nil)
                        (Node 4 Nil Nil))

areEqual expectedResult (mirrorTree tree) -- Очакван резултат: True
```

Нека е даден следният тип за произволно дърво:
```haskell
data Tree = NIl | NOde Int [Tree]
```

- *(10т.)* Да се напише функция, която по подадено произволно дърво го прeвръща в низ спрямо примера.
```haskell
stringifyTree :: Tree -> String

tree :: Tree
tree = NOde 5 [NOde 6 [],
               NOde 7 [NOde 10 [], NOde 11 []],
               NOde 8 [NOde 9 []]]

stringifyTree tree -- Очакван резултат: [5,[[6],[7,[[10],[11]]],[8,[[9]]]]]
```

- *(10т.)* Да се напише функция, която по списък от наредени двойки (баща,дете) конструира n-арно дърво. Приемете, че подаденият списък ще образува валидно дърво(няма да има цикли) и че няма повторение на стойности в резултатното дърво.
```haskell
--           1
--        /     \
--       5       8
--     / |     / | \
--    3  4    9  2  6

buildTree :: [(Int, Int)] -> Tree

tree :: Tree
tree = buildTree [(8,9),(5,3),(5,4),(1,5),(8,2),(1,8),(8,6)]

stringify tree -- Очакван резултат: [1,[[5,[[3],[4]]],[8,[[9],[2],[6]]]]]
```
