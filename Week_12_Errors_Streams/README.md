# Обработка на грешки. Работа с файлове(потоци)

## Обработка на грешки

### Най-прост вариант
```haskell
error <error_message>

head' :: [a] -> a
head' [] = error "Empty list"
head' (x:_) = x
```

*Проблем*: Програмата бива прекъсната чрез грешка по време на компилация. Нарушава се принципът за липса на външни ефекти.

### Типът Maybe
```haskell
type Maybe a = Nothing | Just a
```
Дава възможност в невалидна ситуация да не се прекратява програмата, а просто да се върне стойност, показваща, че е имало някакъв проблем.  
*Проблем*: Настъпилата грешка се **поглъща** и потребителят няма как да придобие повече информация за нея.

```haskell
toLowerLetter :: Char -> Maybe Char
toLowerLetter letter
    | 'A' <= letter && letter <= 'Z' = Just (chr (ord c + offset))
    | True = Nothing
    where
        offset = ord 'a' - ord 'A'
```

### Типът Either
```haskell
data Either a b = Left a | Right b
```
Отново се дава възможност за обработка на грешка в невалидна ситуация без непременно прекъсване на изпълнение на програмата. При възникване на проблем е прието да се връща стойност от тип *а*, а при успех - от тип *b*. По този начин би могло да се даде допълнителен контекст на потребителя и съответно грешката да се обработи коректно.
Друг бонус на ползването на Either е това, че е удобен в комбинация на други по-сложни методи за обработка на грешки от езика(ExceptT и други, които излизат от рамките на курса).

```haskell
-- Enter a natural number between 1 and 1000
validateNum :: Int -> Either String Int
validateNum n
    | n <= 0      = Left "Non-positive number"
    | n > 1000    = Left "Too large number"
    | True        = Right n
```

## Работа с потоци
*def*: Понятието ***поток*** представлява абстракция на последователност от данни, които пристигат във времето за обработка(разбира се, потенциално данните могат да са и *безкрайни*).

### Плюсове на работата с потоци:
- ефективна употреба на паметта;
- отговорът се генерира, без задължително да е зареден целият вход;
- удобство за *chain*-ване на операции(съставяне на *pipeline*-и)

В език като Haskell всичко това е доста естествено поради ленивостта, т.е. цялата обработка на крайни и безкрайни списъци до момента е всъщност обработка на поток.  

Сега ще се съсредоточим над:
### Работа с файлове
Четене:
```haskell
import System.IO

main = do
    content <- readFile "proba.txt" -- лениво се зарежда цялото съдържание на файла
    
    fileHandler <- openFile "proba.txt" ReadMode
    line <- hGetLine fileHandler
    print line
    line <- hGetLine fileHandler
    print line
    hClose fileHandler -- четене на файл ред по ред

    contents <- readFile "proba.txt"
    let fileLines = lines contents in <expr> -- получаване на списък от редове на файл
```
Писане:
```haskell
main = do
    writeFile "out.txt" "Zdr, ko pr" -- презаписвване или създаване на файл

    appendFile "out.txt" "\nnishto brat, ti?"
```

Комбинация:
```haskell
withFile -- полезна функция
```

# Задачи за упражнение
- Дефинирайте тип, описващ човек. Реализирайте записване и зареждане на списък от хора в текстов файл, като всеки човек се записва на нов ред. 