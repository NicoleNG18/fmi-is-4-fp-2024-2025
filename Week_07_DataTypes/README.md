# Алгебрични типове

## Изброен тип
Тип, дефиниран чрез изброяване на своите елементи.
```haskell
data Color = Red | Green | Blue

-- Pattern matching-ът си работи както очакваме:
func :: Color -> Int
func Red = 5
func _   = 15 
```

## Производни типове
*Неформално "кръщаване на вектори"*
```haskell
data Student = Person Name FacNo Year
type Name  = String
type FacNo = Integer
type Year  = Int
```

## Алтернативни типове
Родителски тип в йерархия - комбинация на горните две:
```haskell
data Shape = Circle Double |
             Rectangle Double Double
    deriving (Show, Eq)
```
При образец трябва да се посочва и конкретното име на алтернатива.

## Рекурсивни типове
```haskell
data Expression = Number Int |
                  Add Expression Expression |
                  Sub Expression Expression
```

# Задачи за упражнение

1) Да се дефинира изброен тип, описващ дните от седмицата, и да се състави функция, която проверява дали подаден ден е работен.
```haskell
isWorkingDay :: Day -> Bool
```

2) Книга описваме чрез заглавие, автор, жанр(тук е хубаво да се направи подходящ изброен тип) и година на издаване. Библиотека наричаме списък от наредени двойки, първият елемент на които е някоя книга, а вторият - брой екземпляри от тази книга на разположение.
Да се напише функция, която:
- намира общия брой на книгите в библиотеката;
- дава имената на авторите, написали книги от конкретен жанр;
- подрежда библиотека по азбучен ред.

3) Да се напише тип, описващ биномен коефициент Binom "n над k", и да се напише функция, която да го пресметне.

4) Да се напише тип, който описва естествените числа, и да се напише функция, която пресмята стойността на дадено такова число. След това да се дефинират и функции за сума и произведение на такива естествени числа.

5) Да се напише тип, описващ двоично дърво с елементи цели числа. Да се напише функция, която:
- намира дълбочината на дървото;
- намира броя на елементите на дървото;
- намира броя на листата;
- трансформира елементите на дърво с подадена функция(от цяло число към цяло число);
- агрегира стойностите на дървото:
```haskell
foldTree :: (Int -> a -> a -> a) -> a -> Tree -> a
-- Int е числото във възела, после резултатите съответно от лявото и дясното поддърво, после резултат от цялото дърво, базова стойности при празно дърво, самото дърво и краен резултат
```
- елементите на двоичното дърво да се запишат в списък в ред ляв-корен-десен.